<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sir Knight's Alphabet Adventure</title>
<style>
  body { margin:0; background:#1a0a2e; display:flex; justify-content:center; align-items:center; min-height:100vh; font-family:Georgia,serif; }
  #wrap { position:relative; }
  canvas { display:block; border:8px solid #8B6914; border-radius:4px; box-shadow:0 0 40px #8B691480, 0 0 0 2px #c9a227; cursor:pointer; }
</style>
</head>
<body>
<div id="wrap"><canvas id="c" width="900" height="550"></canvas></div>
<script>
// ─── CONSTANTS ───────────────────────────────────────────────────────────────
const W = 900, H = 550;
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
const LETTER_COLORS = [
  '#e63946','#f4a261','#2a9d8f','#e9c46a','#a8dadc',
  '#457b9d','#f77f00','#6d4c41','#7b2d8b','#00b4d8',
  '#e76f51','#52b788','#ff006e','#fb5607','#8338ec',
  '#3a86ff','#06d6a0','#ef233c','#4361ee','#f72585',
  '#7209b7','#3f37c9','#4895ef','#4cc9f0','#b5179e',
  '#560bad'
];
const HAT_COLORS = [
  '#6a0dad','#c0392b','#1abc9c','#e67e22','#2980b9',
  '#8e44ad','#d35400','#16a085','#c0392b','#2c3e50',
  '#7f8c8d','#f39c12','#1a5276','#6c3483','#117a65',
  '#784212','#1f618d','#922b21','#0e6655','#7d6608',
  '#515a5a','#2e4057','#8e44ad','#148f77','#6e2f19',
  '#1b2631'
];
const NUMBERS = ['0','1','2','3','4','5','6','7','8','9'];
const NUMBER_COLORS = [
  '#f72585','#7209b7','#3a0ca3','#4361ee','#4cc9f0',
  '#06d6a0','#118ab2','#ffd166','#ef233c','#8338ec'
];
const NUMBER_HAT_COLORS = [
  '#c0392b','#1abc9c','#e67e22','#2980b9','#8e44ad',
  '#d35400','#16a085','#c0392b','#2c3e50','#7f8c8d'
];
const WORDS = ['CAT','DOG','PIG','BEE','SUN','HAT','FOX','CUP','HEN','COW','BOX','BED'];
const WORD_COLORS = [
  '#e63946','#f4a261','#ff9fb2','#ffd700','#ffb703',
  '#8b5cf6','#ff6b35','#06d6a0','#fb8500','#2ec4b6','#8b4513','#6c63ff'
];

// ─── HAND-DRAWN HELPERS ───────────────────────────────────────────────────────
// Deterministic jitter (no flicker) — position-seeded sin noise
const JITTER = Array.from({length:512},(_,i)=>Math.sin(i*2.3999+i*i*0.00017)*0.5+Math.sin(i*1.6180)*0.5);
function jit(seed, amp) { return JITTER[(Math.abs(Math.round(seed))&511)] * amp; }

// Wobbly rectangle — hand-inked feel
function roughRect(cx, x, y, w, h, wobble) {
  wobble = wobble||3;
  const s = Math.round(x*3+y*7);
  cx.moveTo(x+jit(s,wobble),    y+jit(s+1,wobble));
  cx.lineTo(x+w+jit(s+2,wobble),y+jit(s+3,wobble));
  cx.lineTo(x+w+jit(s+4,wobble),y+h+jit(s+5,wobble));
  cx.lineTo(x+jit(s+6,wobble),  y+h+jit(s+7,wobble));
  cx.closePath();
}

// Wobbly circle — hand-inked feel
function roughCircle(cx, ox, oy, r, wobble, steps) {
  wobble = wobble||r*0.07; steps = steps||16;
  const s = Math.round(ox*5+oy*11);
  for(let i=0;i<=steps;i++){
    const a=(i/steps)*Math.PI*2;
    const nr=r+jit(s+i,wobble);
    const px=ox+Math.cos(a)*nr, py=oy+Math.sin(a)*nr;
    i===0?cx.moveTo(px,py):cx.lineTo(px,py);
  }
  cx.closePath();
}

// Hatch marks for rustic shading (cross-hatch lines in a box)
function hatch(cx, x, y, w, h, gap, angle, col, alpha) {
  cx.save();
  cx.globalAlpha = alpha||0.12;
  cx.strokeStyle = col||'#3d1a00';
  cx.lineWidth = 0.8;
  cx.beginPath();
  const len = Math.max(w,h)*2;
  for(let d=-len;d<len;d+=gap){
    cx.moveTo(x+d*Math.cos(angle)-len*Math.sin(angle), y+d*Math.sin(angle)+len*Math.cos(angle));
    cx.lineTo(x+d*Math.cos(angle)+len*Math.sin(angle), y+d*Math.sin(angle)-len*Math.cos(angle));
  }
  cx.save(); cx.rect(x,y,w,h); cx.clip(); cx.stroke(); cx.restore();
  cx.restore();
}

// Parchment / paper grain overlay — drawn once, reused
function drawPaperOverlay(cx) {
  cx.save();
  // Very faint brown fibres
  cx.globalAlpha = 0.04;
  cx.strokeStyle = '#6b3a1f';
  cx.lineWidth = 1;
  cx.beginPath();
  for(let i=0;i<80;i++){
    const x1=JITTER[i]*W, y1=JITTER[(i+100)&511]*H;
    cx.moveTo(x1,y1);
    cx.lineTo(x1+JITTER[(i+200)&511]*40-20, y1+JITTER[(i+300)&511]*3);
  }
  cx.stroke();
  // Edge vignette for parchment warmth
  cx.globalAlpha = 1;
  const vig=cx.createRadialGradient(W/2,H/2,H*0.28,W/2,H/2,H*0.85);
  vig.addColorStop(0,'transparent');
  vig.addColorStop(1,'rgba(60,20,5,0.18)');
  cx.fillStyle=vig; cx.fillRect(0,0,W,H);
  cx.restore();
}

// ─── STATE ───────────────────────────────────────────────────────────────────
let state = 'TITLE'; // TITLE | PLAYING | BATTLE | LETTER_DEFEATED | VICTORY
let currentIndex = 0;
let bgOffset = 0;
let frameCount = 0;

// Knight
const knight = { x:120, y:370, vy:0, walking:false, attacking:false, blocking:false,
                  attackTimer:0, blockTimer:0, celebrateTimer:0, bobOffset:0 };

// Enemy
const enemy  = { x:900, y:360, active:false, defeated:false,
                  defeatTimer:0, defeatAngle:0, defeatScale:1,
                  hits:0, hitFlash:0 };

// Particles
let particles = [];

// Victory stars
let stars = [];

// Blink timer for UI
let blinkTimer = 0;

// Phase tracking
let gamePhase = 'LETTERS'; // 'LETTERS' | 'WORDS' | 'NUMBERS'
let numberIndex = 0;
let wordIndex = 0;

// ─── AUDIO ───────────────────────────────────────────────────────────────────
// (filled in step 2)
let audioCtx = null;
let musicGain = null;
let musicScheduled = false;
let musicStartTime = 0;
const BPM = 130;
const BEAT = 60 / BPM;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.18;
  const comp = audioCtx.createDynamicsCompressor();
  musicGain.connect(comp);
  comp.connect(audioCtx.destination);
  startMusic('LETTERS');
}

// Music loop cancellation token
let _musicToken = 0;

function startMusic(phase) {
  _musicToken++; // invalidate any running loop for previous phase
  const token = _musicToken;

  // ── Shared harpsichord voice ──────────────────────────────────────────────
  function hNote(freq, t, dur) {
    const osc  = audioCtx.createOscillator();
    const filt = audioCtx.createBiquadFilter();
    const g    = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    osc.detune.value = Math.sin(freq) * 4;
    filt.type = 'bandpass'; filt.frequency.value = 1600; filt.Q.value = 1.2;
    g.gain.setValueAtTime(0.001, t);
    g.gain.linearRampToValueAtTime(0.6, t + 0.003);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.88);
    osc.connect(filt); filt.connect(g); g.connect(musicGain);
    osc.start(t); osc.stop(t + dur);
  }
  function bassNote(freq, t, dur) {
    const bosc = audioCtx.createOscillator();
    const bg   = audioCtx.createGain();
    bosc.type = 'sine'; bosc.frequency.value = freq;
    bg.gain.setValueAtTime(0.38, t);
    bg.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.92);
    bosc.connect(bg); bg.connect(musicGain);
    bosc.start(t); bosc.stop(t + dur);
  }

  // ── LETTERS phase: D minor, brooding — Dm→Am→Gm→A7→Dm (circle of fifths down) ──
  // Dm=D3/F3/A3, Am=A2/C3/E3/A3, Gm=G2/Bb2/D3/G3, A7=A2/C#3/E3/G3
  const LETTERS_PAT = [
    // Dm arpeggio up+down
    294,349,440,587, 440,349,294,220,
    // Am — fifth below Dm (circle-of-fifths step)
    220,262,330,440, 330,262,220,165,
    // Gm — fifth below Am
    196,233,294,392, 294,233,196,147,
    // A7 cadence back to Dm
    220,277,330,415, 294,349,440,587
  ];
  const LETTERS_BASS = [147,110,98,110]; // D2 A2 G2 A2

  // ── WORDS phase: F major, bright and playful — F→C→G→Am (ascending fifths) ──
  // F=F3/A3/C4, C=C3/E3/G3/C4, G=G3/B3/D4/G4, Am=A3/C4/E4/A4
  const WORDS_PAT = [
    // F major arpeggio
    349,440,523,698, 523,440,349,262,
    // C major — fifth above F
    262,330,392,523, 392,330,262,196,
    // G major — fifth above C
    392,494,587,784, 587,494,392,294,
    // Am — relative minor cadence back
    220,262,330,440, 330,262,220,175
  ];
  const WORDS_BASS = [175,131,196,110]; // F2 C2 G2 A2

  // ── NUMBERS phase: A minor, urgent/tense — Am→Dm→E7→Am (tight minor cadence, faster) ──
  // Am=A3/C4/E4, Dm=D4/F4/A4, E7=E3/G#3/B3/D4
  const NUMBERS_PAT = [
    // Am — quick 16ths, denser
    220,262,330,440, 523,440,330,262,
    // Dm — step down a fifth
    294,349,440,587, 440,349,294,220,
    // E7 — dominant creates tension
    165,208,248,294, 330,294,248,208,
    // Am resolution + ascent
    220,262,330,440, 523,587,659,880
  ];
  const NUMBERS_BASS = [110,147,82,110]; // A2 D2 E2 A2

  const phaseMap = {
    LETTERS: { pat: LETTERS_PAT, bass: LETTERS_BASS, S: 60/108/4  },
    WORDS:   { pat: WORDS_PAT,   bass: WORDS_BASS,   S: 60/116/4  },
    NUMBERS: { pat: NUMBERS_PAT, bass: NUMBERS_BASS, S: 60/126/4  },
  };
  const cfg = phaseMap[phase] || phaseMap.LETTERS;
  const { pat, bass, S } = cfg;
  const loopLen = pat.length * S;

  function scheduleLoop(startT) {
    if (_musicToken !== token) return; // phase changed, stop this loop
    pat.forEach((freq, i) => {
      hNote(freq, startT + i * S, S);
      if (i % 4 === 0) {
        bassNote(bass[Math.floor(i/4) % bass.length], startT + i * S, S * 4);
      }
    });
    const nextStart = startT + loopLen;
    setTimeout(() => scheduleLoop(nextStart),
               Math.max(0, (nextStart - audioCtx.currentTime - 0.5) * 1000));
  }
  scheduleLoop(audioCtx.currentTime + 0.05);
}

function _noise(dur, freq, gain) {
  if (!audioCtx) return;
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const filt = audioCtx.createBiquadFilter();
  filt.type = 'highpass';
  filt.frequency.value = freq;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(gain, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  src.connect(filt); filt.connect(g); g.connect(audioCtx.destination);
  src.start(); src.stop(audioCtx.currentTime + dur);
}

function _tone(freq, type, dur, gainVal, startDelay) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime + (startDelay||0);
  const osc = audioCtx.createOscillator();
  const g   = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.setValueAtTime(gainVal, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t); osc.stop(t + dur);
}

function sfxSword()  { _noise(0.15, 2000, 0.6); }
function sfxChime()  { [523,659,784].forEach((f,i)=>_tone(f,'sine',0.25,0.4,i*0.15)); }
function sfxBwomp()  { _tone(110,'sawtooth',0.2,0.3); }
function sfxStep()   { _noise(0.05, 800, 0.15); }
function sfxVictory() {
  [262,330,392,523].forEach((f,i)=>_tone(f,'sine',0.5,0.35,i*0.12));
  [523,587,659,784].forEach((f,i)=>_tone(f,'sine',0.3,0.25,0.6+i*0.1));
}

// ─── DRAWING ─────────────────────────────────────────────────────────────────
// (filled in step 3)
function drawBackground(ctx) {
  // Sky — warm sepia-toned parchment sky
  const sky = ctx.createLinearGradient(0,0,0,H*0.65);
  sky.addColorStop(0,'#d4b896'); sky.addColorStop(0.5,'#e8d4a8'); sky.addColorStop(1,'#f2e4c0');
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);
  // Rough ink horizon scratch marks
  ctx.save();
  ctx.strokeStyle='#a07040'; ctx.lineWidth=0.7; ctx.globalAlpha=0.15;
  for(let i=0;i<12;i++){
    const hy=H*0.38+jit(i*17,8);
    ctx.beginPath(); ctx.moveTo(i*80,hy); ctx.lineTo(i*80+60+jit(i*31,20),hy+jit(i*13,3)); ctx.stroke();
  }
  ctx.restore();

  // Far castle — detailed stone keep with curtain wall
  const cx2 = ((W*0.75 - bgOffset*0.05) % W + W*1.5) % (W*1.5);
  const ft = audioCtx ? frameCount/60 : 0;
  const cStone='#9988aa', cDark='#6a5a7a', cWall='#b0a0c0', cMort='#5a4a6a';

  // Hill/mound under castle
  ctx.fillStyle='#7a6a8a';
  ctx.beginPath(); ctx.ellipse(cx2,H*0.545,155,52,0,Math.PI,0); ctx.fill();

  // Moat — dark ellipse slice in front of hill
  ctx.fillStyle='#4a6088';
  ctx.beginPath(); ctx.ellipse(cx2,H*0.545,130,18,0,0,Math.PI); ctx.fill();
  ctx.strokeStyle='#38506a'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.ellipse(cx2,H*0.545,130,18,0,0,Math.PI); ctx.stroke();

  // Curtain wall (low connecting wall between towers)
  ctx.fillStyle=cWall;
  ctx.fillRect(cx2-102, H*0.42, 204, 50);
  // Wall crenellations
  ctx.fillStyle=cStone;
  for(let m=-98;m<100;m+=14){
    ctx.fillRect(cx2+m, H*0.42-10, 8, 12);
  }
  // Arrow slits on curtain wall
  ctx.fillStyle=cMort;
  for(let s=-70;s<70;s+=28){
    ctx.fillRect(cx2+s-2, H*0.435, 4, 14);
  }
  // Wall stone courses (horizontal mortar lines)
  ctx.strokeStyle=cMort; ctx.lineWidth=0.8;
  for(let row=0;row<3;row++){
    ctx.beginPath(); ctx.moveTo(cx2-102,H*0.435+row*12); ctx.lineTo(cx2+102,H*0.435+row*12); ctx.stroke();
  }

  // Drawbridge (closed against gate)
  ctx.fillStyle='#5a3a18';
  ctx.fillRect(cx2-18, H*0.46, 36, 30);
  ctx.strokeStyle='#3a2208'; ctx.lineWidth=1.5;
  ctx.strokeRect(cx2-18, H*0.46, 36, 30);
  // Portcullis bars
  ctx.strokeStyle='#2a1a08'; ctx.lineWidth=2;
  for(let b=0;b<5;b++) {
    ctx.beginPath(); ctx.moveTo(cx2-14+b*7,H*0.462); ctx.lineTo(cx2-14+b*7,H*0.488); ctx.stroke();
  }
  ctx.beginPath(); ctx.moveTo(cx2-14,H*0.468); ctx.lineTo(cx2+14,H*0.468); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx2-14,H*0.478); ctx.lineTo(cx2+14,H*0.478); ctx.stroke();
  // Gate arch
  ctx.fillStyle=cDark;
  ctx.beginPath(); ctx.arc(cx2,H*0.46,20,Math.PI,0); ctx.fill();

  // LEFT flanking tower
  const drawTower=(tx,ty,tw,th,hasConical)=>{
    // Tower body
    ctx.fillStyle=cWall;
    ctx.fillRect(tx-tw/2, ty, tw, th);
    // Stone courses
    ctx.strokeStyle=cMort; ctx.lineWidth=0.7;
    for(let r=1;r<th/10;r++){
      ctx.beginPath(); ctx.moveTo(tx-tw/2, ty+r*10); ctx.lineTo(tx+tw/2, ty+r*10); ctx.stroke();
    }
    // Vertical mortar joints (offset per row for ashlar pattern)
    for(let r=0;r<th/10;r++){
      const xOff = (r%2)*9;
      for(let c=-1;c<tw/18+1;c++){
        const jx=tx-tw/2+c*18+xOff;
        if(jx>tx-tw/2 && jx<tx+tw/2){
          ctx.beginPath(); ctx.moveTo(jx,ty+r*10); ctx.lineTo(jx,ty+r*10+10); ctx.stroke();
        }
      }
    }
    // Arrow slits
    ctx.fillStyle=cDark;
    ctx.fillRect(tx-2, ty+th*0.25, 4, 10);
    ctx.fillRect(tx-2, ty+th*0.55, 4, 10);
    // Crenellations
    ctx.fillStyle=cWall;
    ctx.fillRect(tx-tw/2-3, ty-12, tw+6, 4);
    for(let m=-tw/2+1;m<tw/2;m+=10){
      ctx.fillRect(tx+m, ty-22, 7, 12);
    }
    // Conical roof
    if(hasConical){
      ctx.fillStyle='#6a3a55';
      ctx.beginPath();
      ctx.moveTo(tx, ty-40);
      ctx.lineTo(tx-tw/2-4, ty-20);
      ctx.lineTo(tx+tw/2+4, ty-20);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#4a2a3a'; ctx.lineWidth=1.2; ctx.stroke();
    }
    // Flag
    ctx.strokeStyle='#8B6914'; ctx.lineWidth=1.5;
    const fpx = hasConical ? tx : tx+tw/2-4;
    const fpy = hasConical ? ty-40 : ty-22;
    ctx.beginPath(); ctx.moveTo(fpx,fpy); ctx.lineTo(fpx,fpy-22); ctx.stroke();
    ctx.fillStyle='#cc2222';
    ctx.beginPath();
    ctx.moveTo(fpx,fpy-22); ctx.lineTo(fpx+16+Math.sin(ft*1.3+tx)*3,fpy-14); ctx.lineTo(fpx,fpy-6);
    ctx.closePath(); ctx.fill();
  };

  // Left round flanking tower
  drawTower(cx2-88, H*0.34, 34, 82, true);
  // Right round flanking tower
  drawTower(cx2+88, H*0.34, 34, 82, true);

  // Central keep (tallest)
  drawTower(cx2, H*0.26, 48, 100, false);

  // Keep — extra window detail
  ctx.fillStyle=cDark;
  ctx.beginPath(); ctx.arc(cx2, H*0.28+6, 6, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx2-6, H*0.28+6, 12, 10);
  // Second window
  ctx.beginPath(); ctx.arc(cx2, H*0.31+20, 5, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx2-5, H*0.31+20, 10, 8);

  // Outline the whole castle for ink feel
  ctx.strokeStyle=cDark; ctx.lineWidth=1.5;
  ctx.strokeRect(cx2-102, H*0.42, 204, 50);

  // Distant rolling hills — earthy green, rough outline
  const hOff = bgOffset*0.15;
  ctx.fillStyle='#7a9e5a';
  ctx.beginPath(); ctx.moveTo(0,H*0.62);
  for(let x=0;x<=W;x+=18){
    const y=H*0.58+Math.sin((x+hOff)/110)*28+Math.cos((x+hOff)/70)*14
             +jit(Math.round(x/18)*3+77, 2.5);
    ctx.lineTo(x,y);
  }
  ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();
  // Ink outline on hills
  ctx.strokeStyle='#4a6a2a'; ctx.lineWidth=1.8; ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(0,H*0.62);
  for(let x=0;x<=W;x+=18){
    const y=H*0.58+Math.sin((x+hOff)/110)*28+Math.cos((x+hOff)/70)*14
             +jit(Math.round(x/18)*3+77, 2.5);
    ctx.lineTo(x,y);
  }
  ctx.stroke();

  // Mid trees — rough sketchy style
  const tOff = bgOffset*0.3;
  ctx.fillStyle='#4a6e35';
  ctx.strokeStyle='#2d4a1a'; ctx.lineWidth=1.5; ctx.lineJoin='round'; ctx.lineCap='round';
  for(let tx=(-tOff%180+180)%180-180; tx<W+60; tx+=180){
    // Stable seed keyed to world-slot so jitter never changes as trees scroll
    const slot = Math.round((tx + tOff) / 180);
    const seed = ((slot * 73) & 0xfff);
    // Oak — rough wobbly blob
    ctx.beginPath();
    roughCircle(ctx, tx+30, H*0.56, 36, 5, 14);
    ctx.fillStyle='#4a6e35'; ctx.fill();
    ctx.strokeStyle='#2d4a1a'; ctx.stroke();
    // Trunk with slight taper
    ctx.fillStyle='#6b4226';
    ctx.beginPath();
    ctx.moveTo(tx+28+jit(seed,1.5), H*0.56+2);
    ctx.lineTo(tx+32+jit(seed+1,1.5), H*0.56+2);
    ctx.lineTo(tx+30+jit(seed+2,1),   H*0.56+46);
    ctx.lineTo(tx+26+jit(seed+3,1),   H*0.56+46);
    ctx.closePath(); ctx.fill();
    // Fir — rough triangle layers
    const firx=tx+120;
    [[H*0.42,56],[H*0.48,62]].forEach(([ty,hw],li)=>{
      ctx.fillStyle='#3a5c28';
      ctx.beginPath();
      ctx.moveTo(firx+jit(seed+10+li,3), ty);
      ctx.lineTo(firx+hw+jit(seed+11+li,4), ty+H*0.2);
      ctx.lineTo(firx-hw+jit(seed+12+li,4), ty+H*0.2);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#243d17'; ctx.stroke();
    });
  }

  // Wildflowers on hills
  const fOff = bgOffset*0.45;
  for(let i=0;i<30;i++){
    const fx=((i*97+830-fOff*0.6)%W+W)%W;
    const fy=H*0.59+Math.sin(i*1.7)*14;
    const fc=['#ff6b9d','#ffef61','#ff9f43','#a29bfe'][i%4];
    ctx.fillStyle=fc;
    ctx.beginPath(); ctx.arc(fx,fy,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#3d7a3d';
    ctx.fillRect(fx-1,fy,2,10);
  }

  // Ground strip — earthy, rough soil edge
  const gr = ctx.createLinearGradient(0,H*0.72,0,H);
  gr.addColorStop(0,'#6a9e4a'); gr.addColorStop(0.16,'#5e8e40'); gr.addColorStop(0.18,'#b89058');
  gr.addColorStop(1,'#8c6438');
  ctx.fillStyle=gr; ctx.fillRect(0,H*0.72,W,H*0.28);
  // Rough ink edge where grass meets dirt
  ctx.strokeStyle='#3d5a1a'; ctx.lineWidth=2; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(0,H*0.737);
  for(let x=0;x<=W;x+=14){
    ctx.lineTo(x, H*0.737+jit(Math.round(x/14)*5+200, 3));
  }
  ctx.stroke();

  // Cobblestones — wobbly ellipses with ink outlines
  const cOff = bgOffset*0.6;
  ctx.lineCap='round'; ctx.lineJoin='round';
  for(let i=0;i<16;i++){
    const px=((i*58-cOff)%W+W)%W;
    const s=i*7+300;
    const rx=20+jit(s,3), ry=9+jit(s+1,2);
    ctx.fillStyle= i%2===0 ? '#b08860' : '#a87850';
    ctx.beginPath(); roughCircle(ctx,px,H*0.86,0,0,0); // use manual path
    // manual wobbly ellipse
    ctx.beginPath();
    for(let j=0;j<=12;j++){
      const a=(j/12)*Math.PI*2;
      const epx=px+Math.cos(a)*(rx+jit(s+j,2));
      const epy=H*0.86+Math.sin(a)*(ry+jit(s+j+6,1.5));
      j===0?ctx.moveTo(epx,epy):ctx.lineTo(epx,epy);
    }
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#6a4820'; ctx.lineWidth=1.2; ctx.stroke();
    // crack detail
    ctx.strokeStyle='#7a5530'; ctx.lineWidth=0.7; ctx.globalAlpha=0.4;
    ctx.beginPath();
    ctx.moveTo(px-5+jit(s+20,3), H*0.86-2+jit(s+21,2));
    ctx.lineTo(px+6+jit(s+22,3), H*0.86+3+jit(s+23,2));
    ctx.stroke(); ctx.globalAlpha=1;
  }

  // Pennant banners
  const bOff = bgOffset*0.3;
  const bannerColors=['#e63946','#f4a261','#2a9d8f','#e9c46a','#a8dadc','#7b2d8b'];
  for(let bx=(-bOff%240+240)%240-240; bx<W+60; bx+=240){
    ctx.strokeStyle='#8B6914'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(bx+20,H*0.42); ctx.lineTo(bx+220,H*0.44); ctx.stroke();
    for(let p=0;p<6;p++){
      const px=bx+20+p*34;
      const py=H*0.42+p*(0.02/5)*H;
      const col=bannerColors[p%6];
      ctx.fillStyle=col;
      ctx.beginPath();
      ctx.moveTo(px,py); ctx.lineTo(px+14,py); ctx.lineTo(px+7,py+18);
      ctx.closePath(); ctx.fill();
    }
  }
}

function drawKnight(ctx) {
  const t = frameCount/60;
  let ky = knight.y;
  // bob
  const bob = knight.attacking ? 0 : Math.sin(t*3)*2;
  ky += bob;

  // walk leg swing
  let legL=0, legR=0;
  if (knight.walking) {
    legL = Math.sin(t*8)*18;
    legR = -Math.sin(t*8)*18;
  }

  ctx.save();
  ctx.translate(knight.x, ky);

  // Cape — flowing ink strokes with rough edge
  ctx.fillStyle='#5511aa';
  ctx.beginPath();
  ctx.moveTo(-8+jit(60,2),-50);
  ctx.bezierCurveTo(-32,-20,-38+jit(61,3),22,-30+Math.sin(t*2)*9+jit(62,2),58);
  ctx.lineTo(-8+jit(63,2),52); ctx.closePath(); ctx.fill();
  ctx.strokeStyle='#3a0088'; ctx.lineWidth=1.8;
  ctx.beginPath();
  ctx.moveTo(-8,-50);
  ctx.bezierCurveTo(-32,-20,-38+jit(64,3),22,-30+Math.sin(t*2)*9,58);
  ctx.stroke();
  // Cape fold highlights
  ctx.strokeStyle='#8833ee'; ctx.lineWidth=1; ctx.globalAlpha=0.4;
  ctx.beginPath(); ctx.moveTo(-12,-30); ctx.bezierCurveTo(-22,0,-26,25,-20,50); ctx.stroke();
  ctx.globalAlpha=1;

  // Legs — rough ink rectangles with boots
  const drawLeg=(xOff,angle)=>{
    ctx.save(); ctx.translate(xOff,20);
    ctx.rotate(angle*Math.PI/180);
    ctx.fillStyle='#7a9aaa';
    ctx.beginPath(); roughRect(ctx,-7,0,14,32,1.5); ctx.fill();
    ctx.strokeStyle='#3a5566'; ctx.lineWidth=1.5; ctx.beginPath(); roughRect(ctx,-7,0,14,32,1.5); ctx.stroke();
    // Boot
    ctx.fillStyle='#3d2010';
    ctx.beginPath(); roughRect(ctx,-9,28,18,13,2); ctx.fill();
    ctx.strokeStyle='#1a0a00'; ctx.lineWidth=1.2; ctx.beginPath(); roughRect(ctx,-9,28,18,13,2); ctx.stroke();
    ctx.restore();
  };
  drawLeg(-10, legL); drawLeg(10, legR);

  // Set round caps globally for sketchy ink feel
  ctx.lineCap='round'; ctx.lineJoin='round';

  // Body (torso) — rough ink outline
  const torsoCol = knight.blocking ? '#d4a820' : '#7a9aaa';
  ctx.fillStyle = torsoCol;
  ctx.beginPath(); roughRect(ctx,-20,-50,40,72,2.5); ctx.fill();
  ctx.strokeStyle='#3a5566'; ctx.lineWidth=2.2;
  ctx.beginPath(); roughRect(ctx,-20,-50,40,72,2.5); ctx.stroke();
  // Armour plate lines (hand-drawn detail)
  ctx.strokeStyle='#3a5566'; ctx.lineWidth=1.2; ctx.globalAlpha=0.55;
  ctx.beginPath(); ctx.moveTo(-19+jit(1,1.5),-22+jit(2,1)); ctx.lineTo(19+jit(3,1.5),-22+jit(4,1)); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-19+jit(5,1.5), -6+jit(6,1)); ctx.lineTo(19+jit(7,1.5),  -6+jit(8,1)); ctx.stroke();
  ctx.globalAlpha=1;
  // Cross-hatch shading on right side of torso
  hatch(ctx, 2,-50,18,72, 5, Math.PI/4, '#3a5566', 0.10);

  // Shield — rough heater shape
  ctx.fillStyle=knight.blocking?'#e8c800':'#aa1800';
  ctx.beginPath();
  ctx.moveTo(-36+jit(20,2),-45+jit(21,1.5));
  ctx.lineTo(-20+jit(22,1.5),-45+jit(23,1.5));
  ctx.lineTo(-20+jit(24,1.5),  5+jit(25,1.5));
  ctx.quadraticCurveTo(-36+jit(26,2),15+jit(27,1.5),-42+jit(28,2),0+jit(29,1.5));
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
  ctx.beginPath(); roughRect(ctx,-42,-46,22,52,2); ctx.stroke();
  // Gold cross on shield
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(-31+jit(30,1),-20+jit(31,1)); ctx.lineTo(-31+jit(32,1),5+jit(33,1)); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-42+jit(34,1),-6+jit(35,1)); ctx.lineTo(-20+jit(36,1),-6+jit(37,1)); ctx.stroke();

  // Sword arm + sword
  let swordAngle = -15;
  if (knight.attacking) {
    const prog = 1 - knight.attackTimer/36;
    swordAngle = prog < 0.5 ? -80 + prog*2*140 : 60 - (prog*2-1)*75;
  }
  ctx.save(); ctx.translate(20,-30); ctx.rotate(swordAngle*Math.PI/180);
  // arm
  ctx.fillStyle='#7a9aaa';
  ctx.beginPath(); roughRect(ctx,-5,0,10,25,1.5); ctx.fill();
  // blade — slightly tapered, rough edges
  ctx.fillStyle='#d4d4e8';
  ctx.beginPath();
  ctx.moveTo(-3+jit(40,1),25); ctx.lineTo(3+jit(41,1),25);
  ctx.lineTo(1+jit(42,0.8),95); ctx.lineTo(-1+jit(43,0.8),95);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='#8888aa'; ctx.lineWidth=1; ctx.stroke();
  // blade shine scratch
  ctx.strokeStyle='#fff'; ctx.lineWidth=0.8; ctx.globalAlpha=0.5;
  ctx.beginPath(); ctx.moveTo(-1,30); ctx.lineTo(0,80); ctx.stroke(); ctx.globalAlpha=1;
  // hilt cross
  ctx.fillStyle='#cc9900';
  ctx.beginPath(); roughRect(ctx,-14,22,28,6,1.5); ctx.fill();
  ctx.strokeStyle='#8B6914'; ctx.lineWidth=1.2; ctx.beginPath(); roughRect(ctx,-14,22,28,6,1.5); ctx.stroke();
  // gem
  ctx.fillStyle='#dd2244'; ctx.beginPath(); roughCircle(ctx,0,25,4,0.8,8); ctx.fill();
  ctx.restore();

  // Head / Helmet — rough dome
  ctx.fillStyle='#7a9aaa';
  ctx.beginPath(); roughCircle(ctx,0,-65,22,2,12); ctx.fill();
  ctx.strokeStyle='#3a5566'; ctx.lineWidth=2;
  ctx.beginPath(); roughCircle(ctx,0,-65,22,2,12); ctx.stroke();
  // Neck guard
  ctx.fillStyle='#7a9aaa';
  ctx.beginPath(); roughRect(ctx,-22,-65,44,28,2); ctx.fill();
  ctx.strokeStyle='#3a5566'; ctx.lineWidth=2;
  ctx.beginPath(); roughRect(ctx,-22,-65,44,28,2); ctx.stroke();
  // Visor — dark slit
  ctx.fillStyle='#111122';
  ctx.beginPath(); roughRect(ctx,-16,-63,32,16,1.5); ctx.fill();
  ctx.strokeStyle='#444'; ctx.lineWidth=1; ctx.beginPath(); roughRect(ctx,-16,-63,32,16,1.5); ctx.stroke();
  // Rivets on helmet
  [[-15,-58],[15,-58],[0,-72]].forEach(([rx,ry])=>{
    ctx.fillStyle='#aabbc8'; ctx.beginPath(); ctx.arc(rx+jit(rx,1),ry+jit(ry,1),2,0,Math.PI*2); ctx.fill();
  });
  // Plume — ink strokes curving up and back above helmet
  ctx.lineCap='round';
  for(let p=0;p<6;p++){
    const wave=Math.sin(t*4+p)*5;
    ctx.strokeStyle=p%2===0?'#cc2244':'#ee3366';
    ctx.lineWidth=2+p%2*1.5;
    ctx.beginPath();
    ctx.moveTo(-2+jit(p,1.5), -84+jit(p+1,1.5));
    ctx.quadraticCurveTo(
      -14+wave+p*2, -100-p*4,
       -6+wave+p*3, -110-p*5
    );
    ctx.stroke();
  }

  ctx.restore();
}

function drawEnemy(ctx) {
  if (!enemy.active) return;
  const t = frameCount/60;

  // Determine glyph/color/label based on phase
  let glyph, col, hatCol, labelText;
  if (gamePhase === 'LETTERS') {
    glyph = ALPHABET[currentIndex];
    col = LETTER_COLORS[currentIndex];
    hatCol = HAT_COLORS[currentIndex];
    labelText = `The Dastardly Letter ${glyph}!`;
  } else {
    glyph = NUMBERS[numberIndex];
    col = NUMBER_COLORS[numberIndex];
    hatCol = NUMBER_HAT_COLORS[numberIndex];
    labelText = `The Nefarious Number ${glyph}!`;
  }

  const ex = enemy.x;
  const ey = enemy.y;

  ctx.save();
  if (enemy.defeated) {
    ctx.translate(ex, ey);
    ctx.rotate(enemy.defeatAngle);
    ctx.scale(enemy.defeatScale, enemy.defeatScale);
  } else {
    const bounce = Math.sin(t*3)*6;
    ctx.translate(ex, ey + bounce);
  }

  // Glowing aura
  if (!enemy.defeated) {
    const aura = ctx.createRadialGradient(0,0,35,0,0,85);
    aura.addColorStop(0, col+'55');
    aura.addColorStop(1, col+'00');
    ctx.fillStyle = aura;
    ctx.beginPath(); ctx.arc(0,0,85,0,Math.PI*2); ctx.fill();
  }

  // Giant letter glyph — the enemy IS the letter
  ctx.font = 'bold 130px Georgia,serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.strokeStyle = '#1a0a00';
  ctx.lineWidth = 5;
  ctx.strokeText(glyph, 0, 0);
  ctx.fillStyle = enemy.hitFlash > 0 ? '#ffffff' : col;
  ctx.fillText(glyph, 0, 0);

  // Arms — curved lines from letter sides
  ctx.strokeStyle = '#553322';
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(-55,-12); ctx.quadraticCurveTo(-78,5,-72,28); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(55,-12); ctx.quadraticCurveTo(78,5,72,28); ctx.stroke();

  // Legs — oval boots below baseline
  ctx.fillStyle = '#553322';
  ctx.beginPath(); ctx.ellipse(-22,60,16,10,0.3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(22,60,16,10,-0.3,0,Math.PI*2); ctx.fill();

  // Eyes — upper-right area of letter
  [[18,-28],[40,-28]].forEach(([ex2,ey2])=>{
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(ex2,ey2,9,9,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(ex2+1.5,ey2+1,5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ex2+3,ey2-1,2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#333'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(ex2-7,ey2-10); ctx.lineTo(ex2+7,ey2-12); ctx.stroke();
  });

  // Hat — pointy wizard hat on top of letter
  ctx.fillStyle = hatCol;
  ctx.beginPath();
  ctx.moveTo(0,-118); ctx.lineTo(-28,-75); ctx.lineTo(28,-75); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#ffd700';
  ctx.fillRect(-32,-81,64,8);
  ctx.fillStyle='#fffde7';
  ctx.font='14px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('★',0,-105);

  // Health hearts above hat
  for (let h=0; h<3; h++) {
    const hx = -22 + h*22;
    const hy = -148;
    ctx.font='18px serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle = h < (3 - enemy.hits) ? '#e63946' : '#555';
    ctx.fillText('♥', hx, hy);
  }

  ctx.restore();

  // Name label
  if (!enemy.defeated) {
    const bounce2 = Math.sin(frameCount/60*3)*6;
    ctx.fillStyle='#3d1a00';
    ctx.font='italic 13px Georgia,serif';
    ctx.textAlign='center';
    ctx.fillText(labelText, ex, ey + bounce2 + 82);
  }
}

// ── helper: cartoon eye pair ────────────────────────────────────────────────
function drawEyes(ctx, x1,y1, x2,y2, r, irisCol) {
  [[x1,y1],[x2,y2]].forEach(([ex,ey])=>{
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(ex,ey,r,r,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#333'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.ellipse(ex,ey,r,r,0,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle=irisCol||'#222'; ctx.beginPath(); ctx.arc(ex+r*0.2,ey+r*0.2,r*0.55,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ex+r*0.5,ey-r*0.3,r*0.22,0,Math.PI*2); ctx.fill();
  });
}

function drawWordEnemy(ctx) {
  if (!enemy.active) return;
  const t = frameCount/60;
  const word = WORDS[wordIndex];
  const col  = WORD_COLORS[wordIndex];
  const ex   = enemy.x, ey = enemy.y;
  const flash = enemy.hitFlash > 0;

  ctx.save();
  if (enemy.defeated) {
    ctx.translate(ex, ey);
    ctx.rotate(enemy.defeatAngle);
    ctx.scale(enemy.defeatScale, enemy.defeatScale);
  } else {
    ctx.translate(ex, ey + Math.sin(t*3)*6);
  }
  ctx.lineCap='round'; ctx.lineJoin='round';

  // Aura
  if (!enemy.defeated) {
    const aura=ctx.createRadialGradient(0,0,30,0,0,100);
    aura.addColorStop(0,col+'44'); aura.addColorStop(1,col+'00');
    ctx.fillStyle=aura; ctx.beginPath(); ctx.arc(0,0,100,0,Math.PI*2); ctx.fill();
  }

  // ── per-word creature drawing ───────────────────────────────────────────
  const fl = flash ? 0.5 : 1; // opacity multiplier for hit flash tint

  switch(word) {

  case 'CAT': {
    // Body — orange tabby, sitting
    const bc = flash?'#fff':'#e8882a';
    // Tail (behind body)
    ctx.strokeStyle=flash?'#fff':'#c06820'; ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(28,40); ctx.bezierCurveTo(80,30,90,-20,55,-50); ctx.stroke();
    // Body ellipse
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,20,38,42,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a05010'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,20,38,42,0,0,Math.PI*2); ctx.stroke();
    // Head
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,-42,30,28,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a05010'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-42,30,28,0,0,Math.PI*2); ctx.stroke();
    // Ears (pointed triangles)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.moveTo(-26,-60); ctx.lineTo(-14,-42); ctx.lineTo(-6,-72); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(26,-60);  ctx.lineTo(14,-42);  ctx.lineTo(6,-72);  ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#a05010'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(-26,-60); ctx.lineTo(-14,-42); ctx.lineTo(-6,-72); ctx.closePath(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(26,-60);  ctx.lineTo(14,-42);  ctx.lineTo(6,-72);  ctx.closePath(); ctx.stroke();
    // Inner ear pink
    ctx.fillStyle=flash?'#fff':'#ffbbaa';
    ctx.beginPath(); ctx.moveTo(-22,-61); ctx.lineTo(-15,-46); ctx.lineTo(-10,-67); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(22,-61);  ctx.lineTo(15,-46);  ctx.lineTo(10,-67);  ctx.closePath(); ctx.fill();
    // Tabby stripes on forehead
    ctx.strokeStyle=flash?'#ddd':'#c06820'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(-10,-62); ctx.lineTo(-8,-52); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-64);   ctx.lineTo(0,-54);  ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10,-62);  ctx.lineTo(8,-52);  ctx.stroke();
    // Eyes
    drawEyes(ctx,-11,-44,11,-44,7,'#3a8');
    // Nose (pink triangle)
    ctx.fillStyle=flash?'#fff':'#ff99aa';
    ctx.beginPath(); ctx.moveTo(0,-32); ctx.lineTo(-5,-37); ctx.lineTo(5,-37); ctx.closePath(); ctx.fill();
    // Mouth
    ctx.strokeStyle='#553'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(0,-32); ctx.quadraticCurveTo(-8,-26,-12,-28); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-32); ctx.quadraticCurveTo(8,-26,12,-28); ctx.stroke();
    // Whiskers
    ctx.strokeStyle=flash?'#ccc':'#ddd'; ctx.lineWidth=1;
    [[-28,-35,-8,-34],[28,-35,8,-34],[-28,-30,-8,-31],[28,-30,8,-31]].forEach(([x1,y1,x2,y2])=>{
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    });
    // Paws
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-18,58,14,9,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(18,58,14,9,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a05010'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.ellipse(-18,58,14,9,0,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(18,58,14,9,0,0,Math.PI*2); ctx.stroke();
    break;
  }

  case 'DOG': {
    const bc=flash?'#fff':'#c8914a';
    // Floppy ears (behind head)
    ctx.fillStyle=flash?'#eee':'#a0692a';
    ctx.beginPath(); ctx.ellipse(-30,-36,18,30,0.4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(30,-36,18,30,-0.4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#7a4818'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.ellipse(-30,-36,18,30,0.4,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(30,-36,18,30,-0.4,0,Math.PI*2); ctx.stroke();
    // Body
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,22,40,36,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#8a5820'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,22,40,36,0,0,Math.PI*2); ctx.stroke();
    // Tail wagging
    ctx.strokeStyle=bc; ctx.lineWidth=10;
    const tw = Math.sin(t*6)*0.5;
    ctx.beginPath(); ctx.moveTo(35,10); ctx.bezierCurveTo(62,0+tw*30,70,-20+tw*30,60,-40+tw*20); ctx.stroke();
    ctx.strokeStyle='#8a5820'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(35,10); ctx.bezierCurveTo(62,0+tw*30,70,-20+tw*30,60,-40+tw*20); ctx.stroke();
    // Head
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,-40,32,26,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#8a5820'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-40,32,26,0,0,Math.PI*2); ctx.stroke();
    // Muzzle
    ctx.fillStyle=flash?'#fff':'#ddb070';
    ctx.beginPath(); ctx.ellipse(0,-28,16,12,0,0,Math.PI*2); ctx.fill();
    // Eyes
    drawEyes(ctx,-12,-44,12,-44,7,'#553');
    // Nose
    ctx.fillStyle=flash?'#fff':'#222';
    ctx.beginPath(); ctx.ellipse(0,-36,7,5,0,0,Math.PI*2); ctx.fill();
    // Mouth
    ctx.strokeStyle='#553'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(0,-31); ctx.quadraticCurveTo(-9,-24,-13,-26); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-31); ctx.quadraticCurveTo(9,-24,13,-26); ctx.stroke();
    // Legs
    ctx.fillStyle=bc;
    [[-22,48],[-8,54],[8,54],[22,48]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,9,13,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#8a5820'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(lx,ly,9,13,0,0,Math.PI*2); ctx.stroke();
    });
    break;
  }

  case 'PIG': {
    const bc=flash?'#fff':'#f4a0b0';
    // Body — round and pink
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,16,44,40,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c06070'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,16,44,40,0,0,Math.PI*2); ctx.stroke();
    // Head
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,-42,34,30,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c06070'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-42,34,30,0,0,Math.PI*2); ctx.stroke();
    // Ears (rounded triangle)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-26,-68,13,16,-0.2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(26,-68,13,16,0.2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c06070'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.ellipse(-26,-68,13,16,-0.2,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(26,-68,13,16,0.2,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle=flash?'#fff':'#f080a0';
    ctx.beginPath(); ctx.ellipse(-26,-68,8,10,-0.2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(26,-68,8,10,0.2,0,Math.PI*2); ctx.fill();
    // Snout (round disc)
    ctx.fillStyle=flash?'#fff':'#e888a8';
    ctx.beginPath(); ctx.ellipse(0,-28,18,14,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c06070'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(0,-28,18,14,0,0,Math.PI*2); ctx.stroke();
    // Nostrils
    ctx.fillStyle=flash?'#eee':'#c06070';
    ctx.beginPath(); ctx.ellipse(-6,-28,4,5,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(6,-28,4,5,0,0,Math.PI*2); ctx.fill();
    // Eyes
    drawEyes(ctx,-13,-46,13,-46,7,'#553');
    // Curly tail
    ctx.strokeStyle=flash?'#fff':'#e080a0'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.arc(44,10,12,0.2,Math.PI*1.8); ctx.stroke();
    ctx.beginPath(); ctx.arc(52,14,7,0.3,Math.PI*1.7); ctx.stroke();
    // Legs (stubby)
    ctx.fillStyle=bc;
    [[-20,50],[-6,56],[6,56],[20,50]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,9,12,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#c06070'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(lx,ly,9,12,0,0,Math.PI*2); ctx.stroke();
    });
    break;
  }

  case 'BEE': {
    const bc=flash?'#fff':'#ffd700';
    // Wings (behind body)
    ctx.fillStyle='rgba(210,240,255,0.82)';
    ctx.strokeStyle='#aaccdd'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.ellipse(-34,-30,30,20,-0.4,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(34,-30,30,20,0.4,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(-28,-8,22,14,-0.3,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(28,-8,22,14,0.3,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // Abdomen (striped teardrop)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,22,22,34,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#b8860b'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,22,22,34,0,0,Math.PI*2); ctx.stroke();
    // Black stripes on abdomen
    if (!flash) {
      ctx.save(); ctx.beginPath(); ctx.ellipse(0,22,22,34,0,0,Math.PI*2); ctx.clip();
      ctx.fillStyle='#1a0a00';
      ctx.fillRect(-24,4,48,10); ctx.fillRect(-24,22,48,10); ctx.fillRect(-24,40,48,10);
      ctx.restore();
    }
    // Stinger
    ctx.fillStyle=flash?'#fff':'#b8860b';
    ctx.beginPath(); ctx.moveTo(0,56); ctx.lineTo(-4,46); ctx.lineTo(4,46); ctx.closePath(); ctx.fill();
    // Thorax
    ctx.fillStyle=flash?'#fff':'#2a2a00';
    ctx.beginPath(); ctx.ellipse(0,-6,18,16,0,0,Math.PI*2); ctx.fill();
    // Head
    ctx.fillStyle=flash?'#fff':'#ffd700';
    ctx.beginPath(); ctx.ellipse(0,-32,18,16,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#b8860b'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-32,18,16,0,0,Math.PI*2); ctx.stroke();
    // Antennae
    ctx.strokeStyle=flash?'#ccc':'#1a0a00'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(-8,-46); ctx.quadraticCurveTo(-24,-64,-20,-72); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8,-46);  ctx.quadraticCurveTo(24,-64,20,-72);  ctx.stroke();
    ctx.fillStyle=flash?'#fff':'#ffd700';
    ctx.beginPath(); ctx.arc(-20,-72,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(20,-72,4,0,Math.PI*2); ctx.fill();
    // Eyes
    drawEyes(ctx,-8,-33,8,-33,6,'#553');
    break;
  }

  case 'SUN': {
    // Rotating rays
    ctx.save();
    ctx.rotate(t*0.4);
    for(let r=0;r<12;r++){
      const a=(r/12)*Math.PI*2;
      ctx.strokeStyle=flash?'#fff':r%2===0?'#ffdd00':'#ffaa00';
      ctx.lineWidth=r%2===0?7:4;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*44,Math.sin(a)*44);
      ctx.lineTo(Math.cos(a)*80,Math.sin(a)*80);
      ctx.stroke();
    }
    ctx.restore();
    // Body disc
    const sg=ctx.createRadialGradient(0,0,8,0,0,44);
    sg.addColorStop(0,flash?'#fff':'#fff9a0');
    sg.addColorStop(1,flash?'#fff':'#ffcc00');
    ctx.fillStyle=sg;
    ctx.beginPath(); ctx.arc(0,0,44,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=flash?'#ccc':'#e8a000'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(0,0,44,0,Math.PI*2); ctx.stroke();
    // Face
    drawEyes(ctx,-14,-10,14,-10,9,'#e85000');
    // Cheek blush
    ctx.fillStyle='rgba(255,160,80,0.35)';
    ctx.beginPath(); ctx.arc(-22,4,9,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(22,4,9,0,Math.PI*2); ctx.fill();
    // Smile
    ctx.strokeStyle='#c86000'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(0,4,22,0.2,Math.PI-0.2); ctx.stroke();
    break;
  }

  case 'HAT': {
    // A magic top hat, slightly animated — stars drift out
    const bc=flash?'#eee':'#1a1a2e';
    // Brim shadow
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(4,28,56,12,0,0,Math.PI*2); ctx.fill();
    // Hat body
    ctx.fillStyle=bc;
    ctx.beginPath();
    ctx.moveTo(-42,22); ctx.lineTo(-36,-58); ctx.lineTo(36,-58); ctx.lineTo(42,22);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle=flash?'#fff':'#0a0a1a'; ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(-42,22); ctx.lineTo(-36,-58); ctx.lineTo(36,-58); ctx.lineTo(42,22);
    ctx.closePath(); ctx.stroke();
    // Brim
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,22,54,14,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=flash?'#fff':'#0a0a1a'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.ellipse(0,22,54,14,0,0,Math.PI*2); ctx.stroke();
    // Hat band
    ctx.fillStyle=flash?'#fff':'#8B001a';
    ctx.fillRect(-36,8,72,14);
    ctx.strokeStyle=flash?'#eee':'#5a0010'; ctx.lineWidth=1.5;
    ctx.strokeRect(-36,8,72,14);
    // Belt buckle
    ctx.fillStyle=flash?'#fff':'#ffd700';
    ctx.fillRect(-9,9,18,12);
    ctx.strokeStyle=flash?'#ccc':'#c8960c'; ctx.lineWidth=1.5; ctx.strokeRect(-9,9,18,12);
    // Hatband highlight
    ctx.fillStyle=flash?'#fff':'#cc0028'; ctx.fillRect(-6,11,12,8);
    // Stars and sparkles floating out of hat top
    for(let s=0;s<4;s++){
      const sa=(t*1.4+s*1.57)%(Math.PI*2);
      const sr=22+s*10;
      const sx=Math.cos(sa-Math.PI/2)*sr*0.4;
      const sy=-58-20-s*14-(Math.sin(t*2+s)*6);
      ctx.fillStyle=['#ffd700','#fff','#aaeeff','#ffaaff'][s];
      ctx.font='14px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.globalAlpha=0.6+Math.sin(t*3+s)*0.4;
      ctx.fillText('✦',sx,sy);
    }
    ctx.globalAlpha=1;
    // Eyes peeking out from brim shade (hat looks alive)
    drawEyes(ctx,-12,18,12,18,5,'#ffd700');
    break;
  }

  case 'FOX': {
    const bc=flash?'#fff':'#e05c10';
    // Bushy tail (behind body)
    ctx.fillStyle=flash?'#eee':'#e05c10';
    ctx.beginPath(); ctx.moveTo(30,30); ctx.bezierCurveTo(80,10,95,-30,70,-55); ctx.bezierCurveTo(90,-70,75,-80,55,-65); ctx.bezierCurveTo(75,-40,55,0,28,18); ctx.closePath(); ctx.fill();
    ctx.fillStyle=flash?'#fff':'#f8f0e0';
    ctx.beginPath(); ctx.moveTo(50,-62); ctx.bezierCurveTo(70,-65,72,-60,55,-50); ctx.bezierCurveTo(66,-35,50,-10,32,20); ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#a03008'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(30,30); ctx.bezierCurveTo(80,10,95,-30,70,-55); ctx.bezierCurveTo(90,-70,75,-80,55,-65); ctx.bezierCurveTo(75,-40,55,0,28,18); ctx.closePath(); ctx.stroke();
    // Body
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,18,36,38,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a03008'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,18,36,38,0,0,Math.PI*2); ctx.stroke();
    // Chest white patch
    ctx.fillStyle=flash?'#fff':'#f8f0e0';
    ctx.beginPath(); ctx.ellipse(0,24,18,22,0,0,Math.PI*2); ctx.fill();
    // Head
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,-40,28,24,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a03008'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-40,28,24,0,0,Math.PI*2); ctx.stroke();
    // Pointed ears
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.moveTo(-22,-56); ctx.lineTo(-10,-42); ctx.lineTo(-4,-72); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(22,-56);  ctx.lineTo(10,-42);  ctx.lineTo(4,-72);  ctx.closePath(); ctx.fill();
    ctx.fillStyle=flash?'#fff':'#ff9980';
    ctx.beginPath(); ctx.moveTo(-18,-57); ctx.lineTo(-11,-45); ctx.lineTo(-7,-67); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(18,-57);  ctx.lineTo(11,-45);  ctx.lineTo(7,-67);  ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#a03008'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(-22,-56); ctx.lineTo(-10,-42); ctx.lineTo(-4,-72); ctx.closePath(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(22,-56);  ctx.lineTo(10,-42);  ctx.lineTo(4,-72);  ctx.closePath(); ctx.stroke();
    // Pointed muzzle
    ctx.fillStyle=flash?'#fff':'#f8f0e0';
    ctx.beginPath(); ctx.ellipse(0,-26,14,11,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=flash?'#fff':'#222';
    ctx.beginPath(); ctx.ellipse(0,-32,5,4,0,0,Math.PI*2); ctx.fill();
    // Eyes (amber)
    drawEyes(ctx,-10,-43,10,-43,7,'#cc7700');
    // Whiskers
    ctx.strokeStyle=flash?'#ccc':'#ddd'; ctx.lineWidth=1;
    [[-28,-28,-12,-27],[28,-28,12,-27],[-28,-24,-12,-24],[28,-24,12,-24]].forEach(([x1,y1,x2,y2])=>{
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    });
    // Legs
    ctx.fillStyle=bc;
    [[-20,50],[-8,56],[8,56],[20,50]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,9,12,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#a03008'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(lx,ly,9,12,0,0,Math.PI*2); ctx.stroke();
    });
    // Black socks
    ctx.fillStyle=flash?'#aaa':'#1a1a1a';
    [[-20,56],[-8,62],[8,62],[20,56]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,9,7,0,0,Math.PI*2); ctx.fill();
    });
    break;
  }

  case 'CUP': {
    const bc=flash?'#fff':'#f8e8d0';
    // Saucer shadow
    ctx.fillStyle='rgba(0,0,0,0.15)';
    ctx.beginPath(); ctx.ellipse(4,52,46,10,0,0,Math.PI*2); ctx.fill();
    // Saucer
    ctx.fillStyle=flash?'#fff':'#f0d8b8';
    ctx.beginPath(); ctx.ellipse(0,46,46,10,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c0904a'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,46,46,10,0,0,Math.PI*2); ctx.stroke();
    // Cup body (trapezoid with rounded top)
    ctx.fillStyle=bc;
    ctx.beginPath();
    ctx.moveTo(-32,40); ctx.lineTo(-28,-28);
    ctx.arc(0,-28,28,Math.PI,0);
    ctx.lineTo(32,40);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#c0904a'; ctx.lineWidth=2.5; ctx.stroke();
    // Cup rim ellipse top
    ctx.fillStyle=flash?'#fff':'#e8c898';
    ctx.beginPath(); ctx.ellipse(0,-28,28,7,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c0904a'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,-28,28,7,0,0,Math.PI*2); ctx.stroke();
    // Handle
    ctx.strokeStyle='#c0904a'; ctx.lineWidth=8; ctx.lineCap='round';
    ctx.beginPath(); ctx.arc(46,6,20,-Math.PI*0.6,Math.PI*0.6); ctx.stroke();
    ctx.strokeStyle=bc; ctx.lineWidth=4;
    ctx.beginPath(); ctx.arc(46,6,20,-Math.PI*0.6,Math.PI*0.6); ctx.stroke();
    // Floral decoration on cup body
    if (!flash) {
      ctx.fillStyle='#e05898'; ctx.font='22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('❀',0,6);
      ctx.fillStyle='#5bc06a'; ctx.font='14px serif';
      ctx.fillText('✿',-18,16); ctx.fillText('✿',18,16);
    }
    // Steam wisps
    ctx.strokeStyle=flash?'#ddd':'rgba(200,200,200,0.7)'; ctx.lineWidth=3; ctx.lineCap='round';
    for(let s=0;s<3;s++){
      const sx=-12+s*12, sy=-42-s*4;
      const sw=Math.sin(t*2+s*1.2)*8;
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.quadraticCurveTo(sx+sw,sy-16,sx-sw*0.5,sy-32); ctx.stroke();
    }
    // Face on cup
    drawEyes(ctx,-10,0,10,0,7,'#553');
    ctx.strokeStyle='#553'; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(0,18,12,0.2,Math.PI-0.2); ctx.stroke();
    break;
  }

  case 'HEN': {
    const bc=flash?'#fff':'#e8c050';
    // Body (plump teardrop)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-4,14,40,36,0.15,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a07820'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(-4,14,40,36,0.15,0,Math.PI*2); ctx.stroke();
    // Wing detail
    ctx.strokeStyle=flash?'#ddd':'#c09030'; ctx.lineWidth=1.5;
    for(let f=0;f<5;f++){
      ctx.beginPath(); ctx.arc(-4+f*6,28,10+f*2,-Math.PI*0.8,-0.1); ctx.stroke();
    }
    // Tail feathers
    ctx.fillStyle=flash?'#eee':'#c09030';
    for(let f=0;f<3;f++){
      const fa=(f-1)*0.28;
      ctx.beginPath(); ctx.moveTo(32,0); ctx.bezierCurveTo(55+f*4,-10+f*8,60+f*4,-30+f*4,48+f*6,-46+f*8); ctx.lineTo(35,0); ctx.closePath(); ctx.fill();
    }
    ctx.strokeStyle='#a07820'; ctx.lineWidth=1;
    for(let f=0;f<3;f++){
      ctx.beginPath(); ctx.moveTo(32,0); ctx.bezierCurveTo(55+f*4,-10+f*8,60+f*4,-30+f*4,48+f*6,-46+f*8); ctx.stroke();
    }
    // Head
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-8,-38,24,20,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a07820'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(-8,-38,24,20,0,0,Math.PI*2); ctx.stroke();
    // Red comb (3 bumps)
    ctx.fillStyle=flash?'#fff':'#cc1a1a';
    for(let c=0;c<3;c++){
      ctx.beginPath(); ctx.arc(-18+c*8,-56,7,Math.PI,0); ctx.fill();
    }
    ctx.beginPath(); ctx.moveTo(-22,-56); ctx.lineTo(2,-56); ctx.lineTo(2,-52); ctx.lineTo(-22,-52); ctx.closePath(); ctx.fill();
    // Wattle (red dangly)
    ctx.fillStyle=flash?'#fff':'#cc1a1a';
    ctx.beginPath(); ctx.ellipse(-4,-30,6,10,0.2,0,Math.PI*2); ctx.fill();
    // Beak
    ctx.fillStyle=flash?'#fff':'#ffa020';
    ctx.beginPath(); ctx.moveTo(14,-40); ctx.lineTo(30,-36); ctx.lineTo(14,-30); ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#c07010'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(14,-40); ctx.lineTo(30,-36); ctx.lineTo(14,-30); ctx.closePath(); ctx.stroke();
    // Beak opening line
    ctx.beginPath(); ctx.moveTo(14,-36); ctx.lineTo(26,-36); ctx.stroke();
    // Eyes
    drawEyes(ctx,-4,-40,0,-40,7,'#553');
    // Feet
    ctx.strokeStyle=flash?'#ddd':'#ffa020'; ctx.lineWidth=4; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(-14,48); ctx.lineTo(-14,64); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-14,64); ctx.lineTo(-24,72); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-14,64); ctx.lineTo(-8,72); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-14,64); ctx.lineTo(-2,68); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8,48); ctx.lineTo(8,64); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8,64); ctx.lineTo(-2,72); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8,64); ctx.lineTo(14,72); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8,64); ctx.lineTo(20,68); ctx.stroke();
    break;
  }

  case 'COW': {
    const bc=flash?'#fff':'#f5f0e8';
    // Body (large, boxy)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(0,12,50,38,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,12,50,38,0,0,Math.PI*2); ctx.stroke();
    // Black patches
    if (!flash) {
      ctx.fillStyle='#222';
      ctx.beginPath(); ctx.ellipse(-22,4,16,14,0.4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(18,-10,12,18,-0.3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(30,22,10,8,0.5,0,Math.PI*2); ctx.fill();
    }
    // Udder
    ctx.fillStyle=flash?'#fff':'#f8b8c0';
    ctx.beginPath(); ctx.ellipse(0,46,22,12,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#d08090'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(0,46,22,12,0,0,Math.PI*2); ctx.stroke();
    for(let u=0;u<4;u++){
      ctx.beginPath(); ctx.ellipse(-12+u*8,54,4,6,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#d08090'; ctx.beginPath(); ctx.ellipse(-12+u*8,54,4,6,0,0,Math.PI*2); ctx.stroke();
    }
    // Tail
    ctx.strokeStyle=flash?'#ccc':'#888'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(45,10); ctx.bezierCurveTo(62,8,65,-12,52,-28); ctx.stroke();
    ctx.fillStyle=flash?'#ddd':'#555';
    ctx.beginPath(); ctx.arc(51,-30,7,0,Math.PI*2); ctx.fill();
    // Neck
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-14,-28,20,18,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(-14,-28,20,18,0,0,Math.PI*2); ctx.stroke();
    // Head (boxy muzzle)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-12,-52,26,22,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(-12,-52,26,22,0,0,Math.PI*2); ctx.stroke();
    // Horns
    ctx.strokeStyle=flash?'#ddd':'#c8a040'; ctx.lineWidth=5; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(-24,-68); ctx.quadraticCurveTo(-38,-88,-28,-82); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-68); ctx.quadraticCurveTo(14,-88,4,-82); ctx.stroke();
    // Ears (floppy)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.ellipse(-34,-56,12,18,0.4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#888'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(-34,-56,12,18,0.4,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle=flash?'#fff':'#f8c8c8';
    ctx.beginPath(); ctx.ellipse(-34,-56,7,11,0.4,0,Math.PI*2); ctx.fill();
    // Muzzle (big round disc)
    ctx.fillStyle=flash?'#fff':'#e8c0c0';
    ctx.beginPath(); ctx.ellipse(-12,-44,16,12,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c08080'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(-12,-44,16,12,0,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle=flash?'#eee':'#a06060';
    ctx.beginPath(); ctx.ellipse(-18,-44,4,5,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-6,-44,4,5,0,0,Math.PI*2); ctx.fill();
    // Eyes
    drawEyes(ctx,-20,-56,-4,-56,7,'#553');
    // Legs (4 sturdy)
    ctx.fillStyle=bc;
    [[-28,42],[-12,48],[4,48],[20,42]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,11,15,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#888'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.ellipse(lx,ly,11,15,0,0,Math.PI*2); ctx.stroke();
    });
    // Hooves
    ctx.fillStyle=flash?'#aaa':'#333';
    [[-28,54],[-12,60],[4,60],[20,54]].forEach(([lx,ly])=>{
      ctx.beginPath(); ctx.ellipse(lx,ly,11,7,0,0,Math.PI*2); ctx.fill();
    });
    break;
  }

  case 'BOX': {
    const bc=flash?'#fff':'#c8a060';
    const bd=flash?'#eee':'#a07030';
    // Shadow
    ctx.fillStyle='rgba(0,0,0,0.18)';
    ctx.beginPath(); ctx.ellipse(4,58,52,10,0,0,Math.PI*2); ctx.fill();
    // Box body
    ctx.fillStyle=bc;
    ctx.strokeStyle=bd; ctx.lineWidth=3;
    ctx.beginPath(); ctx.rect(-46,-50,92,100); ctx.fill(); ctx.stroke();
    // Wood grain lines (horizontal)
    ctx.strokeStyle=flash?'#eee':bd+'aa'; ctx.lineWidth=1;
    for(let g=0;g<6;g++){
      ctx.beginPath(); ctx.moveTo(-46,-30+g*16); ctx.lineTo(46,-30+g*16); ctx.stroke();
    }
    // Vertical divider line (makes 2 planks)
    ctx.beginPath(); ctx.moveTo(-2,-50); ctx.lineTo(-2,50); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(2,-50); ctx.lineTo(2,50); ctx.stroke();
    // Top face (angled lid lines, isometric hint)
    ctx.fillStyle=flash?'#fff':'#dab870';
    ctx.beginPath(); ctx.moveTo(-46,-50); ctx.lineTo(-30,-64); ctx.lineTo(62,-64); ctx.lineTo(46,-50); ctx.closePath(); ctx.fill();
    ctx.strokeStyle=bd; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-46,-50); ctx.lineTo(-30,-64); ctx.lineTo(62,-64); ctx.lineTo(46,-50); ctx.closePath(); ctx.stroke();
    // Right face (side panel)
    ctx.fillStyle=flash?'#eee':'#b89050';
    ctx.beginPath(); ctx.moveTo(46,-50); ctx.lineTo(62,-64); ctx.lineTo(62,36); ctx.lineTo(46,50); ctx.closePath(); ctx.fill();
    ctx.strokeStyle=bd; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(46,-50); ctx.lineTo(62,-64); ctx.lineTo(62,36); ctx.lineTo(46,50); ctx.closePath(); ctx.stroke();
    // Metal corner brackets
    ctx.strokeStyle=flash?'#ccc':'#888'; ctx.lineWidth=4; ctx.lineCap='square';
    [[-46,-50],[46,-50],[-46,50],[46,50]].forEach(([cx,cy])=>{
      const sx=cx<0?1:-1, sy=cy<0?1:-1;
      ctx.beginPath(); ctx.moveTo(cx,cy+sy*14); ctx.lineTo(cx,cy); ctx.lineTo(cx+sx*14,cy); ctx.stroke();
    });
    // Metal latch
    ctx.fillStyle=flash?'#fff':'#aaa';
    ctx.beginPath(); ctx.roundRect(-8,-6,16,12,3); ctx.fill();
    ctx.strokeStyle=flash?'#ccc':'#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.roundRect(-8,-6,16,12,3); ctx.stroke();
    ctx.fillStyle=flash?'#fff':'#ffd700';
    ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
    // Eyes and smile (box has a face)
    drawEyes(ctx,-18,-18,18,-18,7,'#553');
    ctx.strokeStyle='#553'; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(0,8,16,0.2,Math.PI-0.2); ctx.stroke();
    break;
  }

  case 'BED': {
    const bc=flash?'#fff':'#6a5acd';
    // Bedframe shadow
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(2,58,56,10,0,0,Math.PI*2); ctx.fill();
    // Bed base/frame
    ctx.fillStyle=flash?'#eee':'#5a3a18';
    ctx.beginPath(); ctx.rect(-52,10,104,42); ctx.fill();
    ctx.strokeStyle='#3a1808'; ctx.lineWidth=2.5; ctx.beginPath(); ctx.rect(-52,10,104,42); ctx.stroke();
    // Mattress
    ctx.fillStyle=flash?'#fff':'#e8d8f8';
    ctx.beginPath(); ctx.rect(-48,-4,96,18); ctx.fill();
    ctx.strokeStyle='#c0a0d8'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.rect(-48,-4,96,18); ctx.stroke();
    // Pillow
    ctx.fillStyle=flash?'#fff':'#fff8ff';
    ctx.beginPath(); ctx.roundRect(-42,-8,40,16,6); ctx.fill();
    ctx.strokeStyle='#d0b0e8'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.roundRect(-42,-8,40,16,6); ctx.stroke();
    // Blanket/duvet (covers lower 2/3)
    ctx.fillStyle=bc;
    ctx.beginPath(); ctx.roundRect(-48,2,96,16,4); ctx.fill();
    ctx.strokeStyle=flash?'#ccc':'#4a3a9d'; ctx.lineWidth=2; ctx.beginPath(); ctx.roundRect(-48,2,96,16,4); ctx.stroke();
    // Duvet quilt squares
    if (!flash) {
      ctx.strokeStyle='#5848bd'; ctx.lineWidth=1;
      for(let q=0;q<4;q++){
        ctx.beginPath(); ctx.rect(-44+q*24,2,22,16); ctx.stroke();
      }
    }
    // Headboard
    ctx.fillStyle=flash?'#eee':'#5a3a18';
    ctx.beginPath(); ctx.rect(-52,-50,20,60); ctx.fill();
    ctx.strokeStyle='#3a1808'; ctx.lineWidth=2.5; ctx.beginPath(); ctx.rect(-52,-50,20,60); ctx.stroke();
    // Footboard
    ctx.beginPath(); ctx.rect(32,-28,20,40); ctx.fill();
    ctx.strokeStyle='#3a1808'; ctx.lineWidth=2.5; ctx.beginPath(); ctx.rect(32,-28,20,40); ctx.stroke();
    // Headboard carved arch
    ctx.fillStyle=flash?'#ddd':'#7a5a28';
    ctx.beginPath(); ctx.arc(-42,-42,12,Math.PI,0); ctx.fill();
    // Sleeping face peeking from pillow
    ctx.fillStyle=flash?'#fff':'#f8d8b0';
    ctx.beginPath(); ctx.ellipse(-14,-4,14,12,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#c09060'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.ellipse(-14,-4,14,12,0,0,Math.PI*2); ctx.stroke();
    // Closed eyes (sleeping squiggles)
    ctx.strokeStyle='#553'; ctx.lineWidth=2; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(-21,-6); ctx.quadraticCurveTo(-18,-2,-15,-6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-13,-6); ctx.quadraticCurveTo(-10,-2,-7,-6); ctx.stroke();
    // ZZZ floating up
    ctx.font='bold 16px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let z=0;z<3;z++){
      const zt=(t*1.0+z*0.8)%3;
      ctx.globalAlpha=Math.max(0, 1-zt/3);
      ctx.fillStyle=flash?'#aad4ff':'#8888ff';
      ctx.fillText('Z', -28+z*10+zt*4, -60-zt*22);
    }
    ctx.globalAlpha=1;
    break;
  }

  } // end switch

  // Hearts above creature
  if (!enemy.defeated) {
    for(let h=0;h<3;h++){
      ctx.font='20px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle=h<(3-enemy.hits)?'#e63946':'#444';
      ctx.fillText('♥',-22+h*22,-108);
    }
  }

  ctx.restore();

  // Name label below
  if (!enemy.defeated) {
    const bounce2=Math.sin(frameCount/60*3)*6;
    ctx.fillStyle='#3d1a00'; ctx.font='italic 13px Georgia,serif'; ctx.textAlign='center';
    ctx.fillText(`The Dastardly ${word}!`, ex, ey+bounce2+88);
  }
}

function drawParticles(ctx) {
  particles.forEach(p=>{
    ctx.save();
    ctx.globalAlpha = p.life/p.maxLife;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });
}

function drawHUD(ctx) {
  // Phase progress strip at top
  const stripH = 38;
  ctx.fillStyle='#fffde7dd';
  ctx.beginPath(); ctx.roundRect(10,8,W-20,stripH,10); ctx.fill();
  ctx.strokeStyle='#8B6914'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(10,8,W-20,stripH,10); ctx.stroke();

  if (gamePhase === 'LETTERS') {
    const chipW=(W-40)/26;
    ALPHABET.forEach((letter,i)=>{
      const cx2=20+i*chipW+chipW/2, cy=8+stripH/2, r=13;
      if(i<currentIndex){
        ctx.fillStyle='#2ecc71';
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='bold 13px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(letter,cx2,cy);
      } else if(i===currentIndex){
        const pulse=1+Math.sin(frameCount/8)*0.15;
        ctx.fillStyle='#ffd700';
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#c8960c'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#1a0a00'; ctx.font='bold 13px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(letter,cx2,cy);
      } else {
        ctx.strokeStyle='#aaa'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#999'; ctx.font='11px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(letter,cx2,cy);
      }
    });
    ctx.fillStyle='#3d1a00'; ctx.font='bold 14px Georgia'; ctx.textAlign='left'; ctx.textBaseline='bottom';
    ctx.fillText(`Letter ${currentIndex+1} of 26`,14,H-8);

  } else if (gamePhase === 'WORDS') {
    const chipW=(W-40)/12;
    WORDS.forEach((word,i)=>{
      const cx2=20+i*chipW+chipW/2, cy=8+stripH/2, r=13;
      if(i<wordIndex){
        ctx.fillStyle='#2ecc71';
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='bold 11px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(word[0],cx2,cy);
      } else if(i===wordIndex){
        const pulse=1+Math.sin(frameCount/8)*0.15;
        ctx.fillStyle=WORD_COLORS[i];
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#c8960c'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#fff'; ctx.font='bold 11px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(word[0],cx2,cy);
      } else {
        ctx.strokeStyle='#aaa'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#999'; ctx.font='9px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(word[0],cx2,cy);
      }
    });
    ctx.fillStyle='#3d1a00'; ctx.font='bold 14px Georgia'; ctx.textAlign='left'; ctx.textBaseline='bottom';
    ctx.fillText(`Word ${wordIndex+1} of 12`,14,H-8);

  } else if (gamePhase === 'NUMBERS') {
    const chipW=(W-40)/10;
    NUMBERS.forEach((num,i)=>{
      const cx2=20+i*chipW+chipW/2, cy=8+stripH/2, r=13;
      if(i<numberIndex){
        ctx.fillStyle='#2ecc71';
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='bold 13px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(num,cx2,cy);
      } else if(i===numberIndex){
        const pulse=1+Math.sin(frameCount/8)*0.15;
        ctx.fillStyle=NUMBER_COLORS[i];
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#c8960c'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(cx2,cy,r*pulse,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#fff'; ctx.font='bold 13px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(num,cx2,cy);
      } else {
        ctx.strokeStyle='#aaa'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.arc(cx2,cy,r,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle='#999'; ctx.font='11px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(num,cx2,cy);
      }
    });
    ctx.fillStyle='#3d1a00'; ctx.font='bold 14px Georgia'; ctx.textAlign='left'; ctx.textBaseline='bottom';
    ctx.fillText(`Number ${numberIndex+1} of 10`,14,H-8);
  }

  // Battle prompt
  if (state === 'BATTLE') {
    if (gamePhase === 'WORDS') {
      // Show word with each letter in a coloured box (below creature)
      const word=WORDS[wordIndex];
      const boxW=58, boxH=52, gap=8;
      const totalW=word.length*boxW+(word.length-1)*gap;
      const bx0=W/2-totalW/2, by=H*0.76;
      ctx.fillStyle='#fffde7ee';
      ctx.beginPath(); ctx.roundRect(bx0-16,by,totalW+32,boxH+32,16); ctx.fill();
      ctx.strokeStyle='#ffd700'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.roundRect(bx0-16,by,totalW+32,boxH+32,16); ctx.stroke();
      ctx.fillStyle='#1a0a00'; ctx.font='bold 14px Georgia'; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.fillText(`Type the word! (${enemy.hits}/3)`,W/2,by+5);
      for(let i=0;i<word.length;i++){
        let bgCol,textCol;
        if(enemy.hits>i){bgCol='#2ecc71';textCol='#fff';}
        else if(enemy.hits===i){bgCol=Math.sin(frameCount/8)>0?'#ffd700':'#ffaa00';textCol='#1a0a00';}
        else{bgCol='#888';textCol='#ddd';}
        const lx=bx0+i*(boxW+gap);
        ctx.fillStyle=bgCol;
        ctx.beginPath(); ctx.roundRect(lx,by+20,boxW,boxH,10); ctx.fill();
        ctx.fillStyle=textCol;
        ctx.font='bold 38px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(word[i],lx+boxW/2,by+20+boxH/2);
      }
    } else {
      // Letters or Numbers: key blink prompt
      const displayKey = gamePhase==='LETTERS' ? ALPHABET[currentIndex] : NUMBERS[numberIndex];
      const blink=Math.floor(frameCount/18)%2===0;
      ctx.fillStyle='#fffde7ee';
      ctx.beginPath(); ctx.roundRect(W/2-130,H*0.6,260,80,16); ctx.fill();
      ctx.strokeStyle='#ffd700'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.roundRect(W/2-130,H*0.6,260,80,16); ctx.stroke();
      ctx.fillStyle='#1a0a00'; ctx.font='bold 22px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(`Press the key: (${enemy.hits}/3 hits)`,W/2,H*0.6+22);
      if(blink){
        ctx.fillStyle='#c8960c'; ctx.font='bold 52px Georgia'; ctx.textBaseline='middle';
        ctx.fillText(displayKey,W/2,H*0.6+58);
      }
    }
  }
}

function drawTitle(ctx) {
  // Amber vignette
  const vig = ctx.createRadialGradient(W/2,H/2,80,W/2,H/2,Math.max(W,H)*0.75);
  vig.addColorStop(0,'transparent'); vig.addColorStop(1,'#40200880');
  ctx.fillStyle=vig; ctx.fillRect(0,0,W,H);

  // Title banner scroll
  ctx.fillStyle='#fffde7';
  ctx.beginPath(); ctx.roundRect(80,80,W-160,110,16); ctx.fill();
  ctx.strokeStyle='#8B6914'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.roundRect(80,80,W-160,110,16); ctx.stroke();
  // Scroll curl ends
  ctx.fillStyle='#f5e6b0';
  ctx.beginPath(); ctx.ellipse(80,135,14,55,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(W-80,135,14,55,0,0,Math.PI*2); ctx.fill();

  // Title text
  ctx.fillStyle='#8B4513';
  ctx.strokeStyle='#ffd700';
  ctx.lineWidth=3;
  ctx.font='bold 36px Georgia,serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.strokeText("Sir Knight's Alphabet Adventure",W/2,118);
  ctx.fillText("Sir Knight's Alphabet Adventure",W/2,118);
  ctx.font='italic 18px Georgia,serif';
  ctx.fillStyle='#5a3010';
  ctx.fillText('Defeat the letters A–Z to save the Kingdom!',W/2,158);

  // Animated title knight (left)
  ctx.save(); ctx.translate(120,340);
  const t = frameCount/60;
  const kb = Math.sin(t*4)*3;
  ctx.translate(0,kb);
  // simple mini knight
  ctx.fillStyle='#8aaabb'; ctx.beginPath(); ctx.roundRect(-15,-40,30,55,6); ctx.fill();
  ctx.fillStyle='#7722cc';
  ctx.beginPath(); ctx.moveTo(-6,-40); ctx.bezierCurveTo(-20,-10,-22,20,-18,45); ctx.lineTo(-6,40); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#8aaabb'; ctx.beginPath(); ctx.arc(0,-55,16,Math.PI,0); ctx.fill(); ctx.fillRect(-16,-55,32,20);
  ctx.fillStyle='#1a1a2e'; ctx.beginPath(); ctx.roundRect(-12,-53,24,13,2); ctx.fill();
  ctx.strokeStyle='#ff4466'; ctx.lineWidth=3;
  for(let p=0;p<4;p++){ ctx.beginPath(); ctx.moveTo(-3,-70); ctx.quadraticCurveTo(Math.sin(t*4+p)*5-5+p*3,-60,-3+p*2,-47+p); ctx.stroke(); }
  ctx.fillStyle='#cc2200'; ctx.beginPath(); ctx.moveTo(-28,-35); ctx.lineTo(-16,-35); ctx.lineTo(-16,5); ctx.quadraticCurveTo(-28,12,-32,0); ctx.closePath(); ctx.fill();
  ctx.restore();

  // Animated letter A enemy (right)
  ctx.save(); ctx.translate(W-130,340);
  const ab = Math.sin(t*3)*6;
  ctx.translate(0,ab);
  ctx.fillStyle='#fffde7'; ctx.strokeStyle=LETTER_COLORS[0]; ctx.lineWidth=3;
  ctx.beginPath(); ctx.roundRect(-36,-50,72,70,14); ctx.fill(); ctx.stroke();
  ctx.fillStyle=LETTER_COLORS[0]; ctx.font='bold 60px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('A',0,-12);
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(-10,22,7,7,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10,22,7,7,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(-8,23,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(12,23,3,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // Tiny dragon in sky
  const dx = ((frameCount*0.8)%(W+100))-60;
  const dy = 220 + Math.sin(frameCount/40)*18;
  ctx.save(); ctx.translate(dx,dy);
  const wingFlap = Math.sin(frameCount/8)*0.4;
  ctx.fillStyle='#9b59b6';
  ctx.beginPath(); ctx.ellipse(0,0,22,10,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(18,0,9,0,Math.PI*2); ctx.fill();
  // wings
  ctx.beginPath(); ctx.moveTo(-5,-5); ctx.lineTo(-30,-5-wingFlap*25); ctx.lineTo(-15,8); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-5,5); ctx.lineTo(-30,5+wingFlap*25); ctx.lineTo(-15,-8); ctx.fill();
  // tiny flag
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(20,-9); ctx.lineTo(20,-22); ctx.stroke();
  ctx.fillStyle='#e63946'; ctx.beginPath(); ctx.moveTo(20,-22); ctx.lineTo(32,-17); ctx.lineTo(20,-12); ctx.closePath(); ctx.fill();
  ctx.restore();

  // Click to start
  blinkTimer++;
  if (Math.floor(blinkTimer/35)%2===0) {
    ctx.fillStyle='#ffd700';
    ctx.font='bold 22px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='#8B6914'; ctx.shadowBlur=8;
    ctx.fillText('Click anywhere to begin your quest!',W/2,H-38);
    ctx.shadowBlur=0;
  }
}

function drawVictory(ctx) {
  // Amber overlay
  ctx.fillStyle='#fffde7cc';
  ctx.fillRect(0,0,W,H);

  // Gold stars raining
  stars.forEach(s=>{
    ctx.fillStyle='#ffd700';
    ctx.font=`${s.size}px serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('★',s.x,s.y);
  });

  // Ornate border
  ctx.strokeStyle='#8B6914'; ctx.lineWidth=6;
  ctx.beginPath(); ctx.roundRect(30,30,W-60,H-60,20); ctx.stroke();
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(38,38,W-76,H-76,16); ctx.stroke();

  // Victory text
  ctx.fillStyle='#8B4513';
  ctx.font='bold 52px Georgia,serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=4;
  ctx.strokeText('THE END',W/2,100);
  ctx.fillText('THE END',W/2,100);
  ctx.font='bold 24px Georgia';
  ctx.fillText('You mastered Letters, Words & Numbers!',W/2,148);

  // Letter grid
  const cols=13, chipSize=28, gapX=32, startX=(W-(cols*gapX))/2+16;
  ALPHABET.forEach((letter,i)=>{
    const col2=i%cols, row=Math.floor(i/cols);
    const cx2=startX+col2*gapX, cy2=190+row*38;
    ctx.fillStyle='#2ecc71';
    ctx.beginPath(); ctx.arc(cx2,cy2,13,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='bold 13px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(letter,cx2,cy2);
  });

  // Celebrating knight
  ctx.save(); ctx.translate(180,380);
  const t=frameCount/60;
  const jmp=Math.abs(Math.sin(t*4))*-20;
  ctx.translate(0,jmp);
  ctx.fillStyle='#8aaabb'; ctx.beginPath(); ctx.roundRect(-15,-40,30,55,6); ctx.fill();
  ctx.fillStyle='#7722cc'; ctx.beginPath(); ctx.moveTo(-6,-40); ctx.bezierCurveTo(-20,-10,-22,20,-18,45); ctx.lineTo(-6,40); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#8aaabb'; ctx.beginPath(); ctx.arc(0,-55,16,Math.PI,0); ctx.fill(); ctx.fillRect(-16,-55,32,20);
  ctx.fillStyle='#1a1a2e'; ctx.beginPath(); ctx.roundRect(-12,-53,24,13,2); ctx.fill();
  // sword raised
  ctx.save(); ctx.translate(16,-20); ctx.rotate(-Math.PI/2+Math.sin(t*4)*0.3);
  ctx.fillStyle='#e8e8f0'; ctx.beginPath(); ctx.moveTo(-2,0); ctx.lineTo(2,0); ctx.lineTo(1,70); ctx.lineTo(-1,70); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#ffd700'; ctx.fillRect(-12,-4,24,5);
  ctx.restore();
  ctx.restore();

  // Play Again button
  ctx.fillStyle='#8B6914';
  ctx.beginPath(); ctx.roundRect(W/2-90,H-95,180,48,12); ctx.fill();
  ctx.fillStyle='#ffd700'; ctx.font='bold 22px Georgia'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('⚜ Play Again ⚜',W/2,H-71);
}

// ─── GAME LOGIC ──────────────────────────────────────────────────────────────
// (filled in step 4)
let stepTimer = 0;

function update() {
  blinkTimer++;
  frameCount++;

  if (state === 'TITLE' || state === 'VICTORY') {
    // Animate victory stars
    if (state === 'VICTORY') {
      stars.forEach(s=>{ s.y += s.speed; if(s.y>H+20) s.y=-20; });
    }
    return;
  }

  // Update particles
  particles.forEach(p=>{
    p.x += p.vx; p.y += p.vy; p.vy += 0.2;
    p.life--;
  });
  particles = particles.filter(p=>p.life>0);

  // Knight block flash decay
  if (knight.blockTimer > 0) {
    knight.blockTimer--;
    if (knight.blockTimer === 0) knight.blocking = false;
  }

  if (state === 'PLAYING') {
    knight.walking = true;
    bgOffset += 1.5;

    // Footstep SFX
    stepTimer++;
    if (stepTimer >= 26) { stepTimer=0; sfxStep(); }

    // Enemy walks left
    if (enemy.active && enemy.x > 490) {
      enemy.x -= 1.5;
    } else if (enemy.active && enemy.x <= 490) {
      // Enter battle
      enemy.x = 490;
      knight.walking = false;
      state = 'BATTLE';
    }

  } else if (state === 'BATTLE') {
    knight.walking = false;

    // Knight attack animation
    if (knight.attacking) {
      knight.attackTimer--;
      if (knight.attackTimer <= 0) {
        knight.attacking = false;
        registerHit();
      }
    }
    // Hit flash decay
    if (enemy.hitFlash > 0) enemy.hitFlash--;

  } else if (state === 'LETTER_DEFEATED') {
    enemy.defeatTimer--;
    enemy.defeatAngle += 0.18;
    enemy.defeatScale = Math.max(0, enemy.defeatTimer/42);

    if (enemy.defeatTimer <= 0) {
      enemy.active = false;
      enemy.defeated = false;
      enemy.defeatScale = 1;
      enemy.defeatAngle = 0;

      if (gamePhase === 'LETTERS') {
        currentIndex++;
        if (currentIndex >= 26) {
          gamePhase = 'WORDS';
          wordIndex = 0;
          if (audioCtx) startMusic('WORDS');
          state = 'PLAYING';
          spawnEnemy();
        } else {
          state = 'PLAYING';
          spawnEnemy();
        }
      } else if (gamePhase === 'WORDS') {
        wordIndex++;
        if (wordIndex >= WORDS.length) {
          gamePhase = 'NUMBERS';
          numberIndex = 0;
          if (audioCtx) startMusic('NUMBERS');
          state = 'PLAYING';
          spawnEnemy();
        } else {
          state = 'PLAYING';
          spawnEnemy();
        }
      } else if (gamePhase === 'NUMBERS') {
        numberIndex++;
        if (numberIndex >= NUMBERS.length) {
          state = 'VICTORY';
          sfxVictory();
          spawnStars();
        } else {
          state = 'PLAYING';
          spawnEnemy();
        }
      }
    }
  }
}

function spawnEnemy() {
  enemy.x = 880;
  enemy.y = 360;
  enemy.active = true;
  enemy.defeated = false;
  enemy.defeatTimer = 0;
  enemy.defeatAngle = 0;
  enemy.defeatScale = 1;
  enemy.hits = 0;
  enemy.hitFlash = 0;
}

function triggerAttack() {
  if (knight.attacking) return;
  knight.attacking = true;
  knight.attackTimer = 36;
  sfxSword();
}

function currentColor() {
  if (gamePhase === 'LETTERS') return LETTER_COLORS[currentIndex];
  if (gamePhase === 'NUMBERS') return NUMBER_COLORS[numberIndex];
  return WORD_COLORS[wordIndex];
}

function registerHit() {
  enemy.hits++;
  spawnParticles(enemy.x, enemy.y - 20, currentColor());
  if (enemy.hits >= 3) {
    triggerDefeat();
  } else {
    enemy.hitFlash = 22;
    sfxChime();
  }
}

function triggerDefeat() {
  enemy.defeated = true;
  enemy.defeatTimer = 42;
  state = 'LETTER_DEFEATED';
  sfxChime();
  spawnParticles(enemy.x, enemy.y, currentColor());
}

function spawnParticles(x,y,color) {
  for (let i=0;i<14;i++) {
    const angle = (i/14)*Math.PI*2;
    const speed = 3+Math.random()*4;
    particles.push({
      x, y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed - 2,
      r: 4+Math.random()*4,
      color,
      life: 40+Math.random()*20,
      maxLife: 60
    });
  }
}

function spawnStars() {
  stars = [];
  for(let i=0;i<30;i++){
    stars.push({
      x: Math.random()*W,
      y: Math.random()*H - H,
      speed: 1+Math.random()*2,
      size: 14+Math.random()*18
    });
  }
}

function resetGame() {
  gamePhase = 'LETTERS';
  currentIndex = 0;
  numberIndex = 0;
  wordIndex = 0;
  bgOffset = 0;
  frameCount = 0;
  particles = [];
  stars = [];
  knight.walking = false;
  knight.attacking = false;
  knight.blocking = false;
  knight.attackTimer = 0;
  knight.blockTimer = 0;
  enemy.active = false;
  enemy.defeated = false;
  if (audioCtx) startMusic('LETTERS');
  state = 'PLAYING';
  spawnEnemy();
}

// ─── MAIN LOOP ────────────────────────────────────────────────────────────────
// (filled in step 4)
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

function loop() {
  update();
  ctx.clearRect(0,0,W,H);
  if (state === 'TITLE') {
    drawBackground(ctx);
    drawTitle(ctx);
  } else if (state === 'VICTORY') {
    drawBackground(ctx);
    drawVictory(ctx);
  } else {
    drawBackground(ctx);
    drawParticles(ctx);
    drawKnight(ctx);
    if (enemy.active) {
      if (gamePhase === 'WORDS') drawWordEnemy(ctx);
      else drawEnemy(ctx);
    }
    drawHUD(ctx);
  }
  drawPaperOverlay(ctx);
  requestAnimationFrame(loop);
}

// ─── EVENT LISTENERS ─────────────────────────────────────────────────────────
canvas.addEventListener('click', function(e) {
  if (state === 'TITLE') {
    initAudio();
    state = 'PLAYING';
    spawnEnemy();
  } else if (state === 'VICTORY') {
    resetGame();
  }
});

document.addEventListener('keydown', function(e) {
  if (state !== 'BATTLE') return;
  const key = e.key.toUpperCase();

  let expectedKey;
  if      (gamePhase === 'LETTERS') expectedKey = ALPHABET[currentIndex];
  else if (gamePhase === 'NUMBERS') expectedKey = NUMBERS[numberIndex];
  else if (gamePhase === 'WORDS')   expectedKey = WORDS[wordIndex][enemy.hits];

  if (key === expectedKey) {
    triggerAttack();
  } else {
    const isLetter = key.length===1 && key>='A' && key<='Z';
    const isDigit  = key.length===1 && key>='0' && key<='9';
    const wrongTyping = (gamePhase==='NUMBERS' ? isDigit : isLetter);
    if (wrongTyping) {
      knight.blocking  = true;
      knight.blockTimer = 30;
      sfxBwomp();
    }
  }
});

requestAnimationFrame(loop);
</script>
</body>
</html>
